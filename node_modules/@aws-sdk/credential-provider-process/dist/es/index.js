import { __awaiter, __generator } from "tslib";
import { getMasterProfileName, parseKnownFiles } from "@aws-sdk/credential-provider-ini";
import { ProviderError } from "@aws-sdk/property-provider";
import { exec } from "child_process";
export var ENV_PROFILE = "AWS_PROFILE";
/**
 * Creates a credential provider that will read from a credential_process specified
 * in ini files.
 */
export function fromProcess(init) {
    if (init === void 0) { init = {}; }
    return function () {
        return parseKnownFiles(init).then(function (profiles) { return resolveProcessCredentials(getMasterProfileName(init), profiles, init); });
    };
}
function resolveProcessCredentials(profileName, profiles, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
options) {
    return __awaiter(this, void 0, void 0, function () {
        var profile, credentialProcess;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    profile = profiles[profileName];
                    if (!profiles[profileName]) return [3 /*break*/, 4];
                    credentialProcess = profile["credential_process"];
                    if (!(credentialProcess !== undefined)) return [3 /*break*/, 2];
                    return [4 /*yield*/, execPromise(credentialProcess)
                            .then(function (processResult) {
                            var data;
                            try {
                                data = JSON.parse(processResult);
                            }
                            catch (_a) {
                                throw Error("Profile " + profileName + " credential_process returned invalid JSON.");
                            }
                            var version = data.Version, accessKeyId = data.AccessKeyId, secretAccessKey = data.SecretAccessKey, sessionToken = data.SessionToken, expiration = data.Expiration;
                            if (version !== 1) {
                                throw Error("Profile " + profileName + " credential_process did not return Version 1.");
                            }
                            if (accessKeyId === undefined || secretAccessKey === undefined) {
                                throw Error("Profile " + profileName + " credential_process returned invalid credentials.");
                            }
                            var expirationUnix;
                            if (expiration) {
                                var currentTime = new Date();
                                var expireTime = new Date(expiration);
                                if (expireTime < currentTime) {
                                    throw Error("Profile " + profileName + " credential_process returned expired credentials.");
                                }
                                expirationUnix = Math.floor(new Date(expiration).valueOf() / 1000);
                            }
                            return {
                                accessKeyId: accessKeyId,
                                secretAccessKey: secretAccessKey,
                                sessionToken: sessionToken,
                                expirationUnix: expirationUnix,
                            };
                        })
                            .catch(function (error) {
                            throw new ProviderError(error.message);
                        })];
                case 1: return [2 /*return*/, _a.sent()];
                case 2: throw new ProviderError("Profile " + profileName + " did not contain credential_process.");
                case 3: return [3 /*break*/, 5];
                case 4: 
                // If the profile cannot be parsed or does not contain the default or
                // specified profile throw an error. This should be considered a terminal
                // resolution error if a profile has been specified by the user (whether via
                // a parameter, anenvironment variable, or another profile's `source_profile` key).
                throw new ProviderError("Profile " + profileName + " could not be found in shared credentials file.");
                case 5: return [2 /*return*/];
            }
        });
    });
}
function execPromise(command) {
    return new Promise(function (resolve, reject) {
        exec(command, function (error, stdout) {
            if (error) {
                reject(error);
                return;
            }
            resolve(stdout.trim());
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxlQUFlLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUN6RixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFHM0QsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVyQyxNQUFNLENBQUMsSUFBTSxXQUFXLEdBQUcsYUFBYSxDQUFDO0FBZXpDOzs7R0FHRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQUMsSUFBMEI7SUFBMUIscUJBQUEsRUFBQSxTQUEwQjtJQUNwRCxPQUFPO1FBQ0wsT0FBQSxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQUMsUUFBUSxJQUFLLE9BQUEseUJBQXlCLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFyRSxDQUFxRSxDQUFDO0lBQS9HLENBQStHLENBQUM7QUFDcEgsQ0FBQztBQUVELFNBQWUseUJBQXlCLENBQ3RDLFdBQW1CLEVBQ25CLFFBQXVCO0FBQ3ZCLDZEQUE2RDtBQUM3RCxPQUF3Qjs7Ozs7O29CQUVsQixPQUFPLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO3lCQUVsQyxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQXJCLHdCQUFxQjtvQkFDakIsaUJBQWlCLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUM7eUJBQ3BELENBQUEsaUJBQWlCLEtBQUssU0FBUyxDQUFBLEVBQS9CLHdCQUErQjtvQkFDMUIscUJBQU0sV0FBVyxDQUFDLGlCQUFpQixDQUFDOzZCQUN4QyxJQUFJLENBQUMsVUFBQyxhQUFrQjs0QkFDdkIsSUFBSSxJQUFJLENBQUM7NEJBQ1QsSUFBSTtnQ0FDRixJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQzs2QkFDbEM7NEJBQUMsV0FBTTtnQ0FDTixNQUFNLEtBQUssQ0FBQyxhQUFXLFdBQVcsK0NBQTRDLENBQUMsQ0FBQzs2QkFDakY7NEJBR0MsSUFBUyxPQUFPLEdBS2QsSUFBSSxRQUxVLEVBQ0gsV0FBVyxHQUl0QixJQUFJLFlBSmtCLEVBQ1AsZUFBZSxHQUc5QixJQUFJLGdCQUgwQixFQUNsQixZQUFZLEdBRXhCLElBQUksYUFGb0IsRUFDZCxVQUFVLEdBQ3BCLElBQUksV0FEZ0IsQ0FDZjs0QkFFVCxJQUFJLE9BQU8sS0FBSyxDQUFDLEVBQUU7Z0NBQ2pCLE1BQU0sS0FBSyxDQUFDLGFBQVcsV0FBVyxrREFBK0MsQ0FBQyxDQUFDOzZCQUNwRjs0QkFFRCxJQUFJLFdBQVcsS0FBSyxTQUFTLElBQUksZUFBZSxLQUFLLFNBQVMsRUFBRTtnQ0FDOUQsTUFBTSxLQUFLLENBQUMsYUFBVyxXQUFXLHNEQUFtRCxDQUFDLENBQUM7NkJBQ3hGOzRCQUVELElBQUksY0FBYyxDQUFDOzRCQUVuQixJQUFJLFVBQVUsRUFBRTtnQ0FDZCxJQUFNLFdBQVcsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO2dDQUMvQixJQUFNLFVBQVUsR0FBRyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQ0FDeEMsSUFBSSxVQUFVLEdBQUcsV0FBVyxFQUFFO29DQUM1QixNQUFNLEtBQUssQ0FBQyxhQUFXLFdBQVcsc0RBQW1ELENBQUMsQ0FBQztpQ0FDeEY7Z0NBQ0QsY0FBYyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTyxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUM7NkJBQ3BFOzRCQUVELE9BQU87Z0NBQ0wsV0FBVyxhQUFBO2dDQUNYLGVBQWUsaUJBQUE7Z0NBQ2YsWUFBWSxjQUFBO2dDQUNaLGNBQWMsZ0JBQUE7NkJBQ2YsQ0FBQzt3QkFDSixDQUFDLENBQUM7NkJBQ0QsS0FBSyxDQUFDLFVBQUMsS0FBWTs0QkFDbEIsTUFBTSxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7d0JBQ3pDLENBQUMsQ0FBQyxFQUFBO3dCQTdDSixzQkFBTyxTQTZDSCxFQUFDO3dCQUVMLE1BQU0sSUFBSSxhQUFhLENBQUMsYUFBVyxXQUFXLHlDQUFzQyxDQUFDLENBQUM7OztnQkFHeEYscUVBQXFFO2dCQUNyRSx5RUFBeUU7Z0JBQ3pFLDRFQUE0RTtnQkFDNUUsbUZBQW1GO2dCQUNuRixNQUFNLElBQUksYUFBYSxDQUFDLGFBQVcsV0FBVyxvREFBaUQsQ0FBQyxDQUFDOzs7OztDQUVwRztBQUVELFNBQVMsV0FBVyxDQUFDLE9BQWU7SUFDbEMsT0FBTyxJQUFJLE9BQU8sQ0FBQyxVQUFVLE9BQU8sRUFBRSxNQUFNO1FBQzFDLElBQUksQ0FBQyxPQUFPLEVBQUUsVUFBQyxLQUFLLEVBQUUsTUFBTTtZQUMxQixJQUFJLEtBQUssRUFBRTtnQkFDVCxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ2QsT0FBTzthQUNSO1lBRUQsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TWFzdGVyUHJvZmlsZU5hbWUsIHBhcnNlS25vd25GaWxlcyB9IGZyb20gXCJAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVyLWluaVwiO1xuaW1wb3J0IHsgUHJvdmlkZXJFcnJvciB9IGZyb20gXCJAYXdzLXNkay9wcm9wZXJ0eS1wcm92aWRlclwiO1xuaW1wb3J0IHsgUGFyc2VkSW5pRGF0YSwgU2hhcmVkQ29uZmlnRmlsZXMsIFNoYXJlZENvbmZpZ0luaXQgfSBmcm9tIFwiQGF3cy1zZGsvc2hhcmVkLWluaS1maWxlLWxvYWRlclwiO1xuaW1wb3J0IHsgQ3JlZGVudGlhbFByb3ZpZGVyLCBDcmVkZW50aWFscyB9IGZyb20gXCJAYXdzLXNkay90eXBlc1wiO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5cbmV4cG9ydCBjb25zdCBFTlZfUFJPRklMRSA9IFwiQVdTX1BST0ZJTEVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBGcm9tUHJvY2Vzc0luaXQgZXh0ZW5kcyBTaGFyZWRDb25maWdJbml0IHtcbiAgLyoqXG4gICAqIFRoZSBjb25maWd1cmF0aW9uIHByb2ZpbGUgdG8gdXNlLlxuICAgKi9cbiAgcHJvZmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIGxvYWRlZCBhbmQgcGFyc2VkIGNyZWRlbnRpYWxzIGZpbGVzLlxuICAgKiBVc2VkIHRvIGF2b2lkIGxvYWRpbmcgc2hhcmVkIGNvbmZpZyBmaWxlcyBtdWx0aXBsZSB0aW1lcy5cbiAgICovXG4gIGxvYWRlZENvbmZpZz86IFByb21pc2U8U2hhcmVkQ29uZmlnRmlsZXM+O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjcmVkZW50aWFsIHByb3ZpZGVyIHRoYXQgd2lsbCByZWFkIGZyb20gYSBjcmVkZW50aWFsX3Byb2Nlc3Mgc3BlY2lmaWVkXG4gKiBpbiBpbmkgZmlsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUHJvY2Vzcyhpbml0OiBGcm9tUHJvY2Vzc0luaXQgPSB7fSk6IENyZWRlbnRpYWxQcm92aWRlciB7XG4gIHJldHVybiAoKSA9PlxuICAgIHBhcnNlS25vd25GaWxlcyhpbml0KS50aGVuKChwcm9maWxlcykgPT4gcmVzb2x2ZVByb2Nlc3NDcmVkZW50aWFscyhnZXRNYXN0ZXJQcm9maWxlTmFtZShpbml0KSwgcHJvZmlsZXMsIGluaXQpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVByb2Nlc3NDcmVkZW50aWFscyhcbiAgcHJvZmlsZU5hbWU6IHN0cmluZyxcbiAgcHJvZmlsZXM6IFBhcnNlZEluaURhdGEsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgb3B0aW9uczogRnJvbVByb2Nlc3NJbml0XG4pOiBQcm9taXNlPENyZWRlbnRpYWxzPiB7XG4gIGNvbnN0IHByb2ZpbGUgPSBwcm9maWxlc1twcm9maWxlTmFtZV07XG5cbiAgaWYgKHByb2ZpbGVzW3Byb2ZpbGVOYW1lXSkge1xuICAgIGNvbnN0IGNyZWRlbnRpYWxQcm9jZXNzID0gcHJvZmlsZVtcImNyZWRlbnRpYWxfcHJvY2Vzc1wiXTtcbiAgICBpZiAoY3JlZGVudGlhbFByb2Nlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGF3YWl0IGV4ZWNQcm9taXNlKGNyZWRlbnRpYWxQcm9jZXNzKVxuICAgICAgICAudGhlbigocHJvY2Vzc1Jlc3VsdDogYW55KSA9PiB7XG4gICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHByb2Nlc3NSZXN1bHQpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFByb2ZpbGUgJHtwcm9maWxlTmFtZX0gY3JlZGVudGlhbF9wcm9jZXNzIHJldHVybmVkIGludmFsaWQgSlNPTi5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBWZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgQWNjZXNzS2V5SWQ6IGFjY2Vzc0tleUlkLFxuICAgICAgICAgICAgU2VjcmV0QWNjZXNzS2V5OiBzZWNyZXRBY2Nlc3NLZXksXG4gICAgICAgICAgICBTZXNzaW9uVG9rZW46IHNlc3Npb25Ub2tlbixcbiAgICAgICAgICAgIEV4cGlyYXRpb246IGV4cGlyYXRpb24sXG4gICAgICAgICAgfSA9IGRhdGE7XG5cbiAgICAgICAgICBpZiAodmVyc2lvbiAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFByb2ZpbGUgJHtwcm9maWxlTmFtZX0gY3JlZGVudGlhbF9wcm9jZXNzIGRpZCBub3QgcmV0dXJuIFZlcnNpb24gMS5gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWNjZXNzS2V5SWQgPT09IHVuZGVmaW5lZCB8fCBzZWNyZXRBY2Nlc3NLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFByb2ZpbGUgJHtwcm9maWxlTmFtZX0gY3JlZGVudGlhbF9wcm9jZXNzIHJldHVybmVkIGludmFsaWQgY3JlZGVudGlhbHMuYCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGV4cGlyYXRpb25Vbml4O1xuXG4gICAgICAgICAgaWYgKGV4cGlyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZVRpbWUgPSBuZXcgRGF0ZShleHBpcmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChleHBpcmVUaW1lIDwgY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFByb2ZpbGUgJHtwcm9maWxlTmFtZX0gY3JlZGVudGlhbF9wcm9jZXNzIHJldHVybmVkIGV4cGlyZWQgY3JlZGVudGlhbHMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBpcmF0aW9uVW5peCA9IE1hdGguZmxvb3IobmV3IERhdGUoZXhwaXJhdGlvbikudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFjY2Vzc0tleUlkLFxuICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5LFxuICAgICAgICAgICAgc2Vzc2lvblRva2VuLFxuICAgICAgICAgICAgZXhwaXJhdGlvblVuaXgsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnJvcjogRXJyb3IpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgUHJvdmlkZXJFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQcm92aWRlckVycm9yKGBQcm9maWxlICR7cHJvZmlsZU5hbWV9IGRpZCBub3QgY29udGFpbiBjcmVkZW50aWFsX3Byb2Nlc3MuYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBwcm9maWxlIGNhbm5vdCBiZSBwYXJzZWQgb3IgZG9lcyBub3QgY29udGFpbiB0aGUgZGVmYXVsdCBvclxuICAgIC8vIHNwZWNpZmllZCBwcm9maWxlIHRocm93IGFuIGVycm9yLiBUaGlzIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgdGVybWluYWxcbiAgICAvLyByZXNvbHV0aW9uIGVycm9yIGlmIGEgcHJvZmlsZSBoYXMgYmVlbiBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgKHdoZXRoZXIgdmlhXG4gICAgLy8gYSBwYXJhbWV0ZXIsIGFuZW52aXJvbm1lbnQgdmFyaWFibGUsIG9yIGFub3RoZXIgcHJvZmlsZSdzIGBzb3VyY2VfcHJvZmlsZWAga2V5KS5cbiAgICB0aHJvdyBuZXcgUHJvdmlkZXJFcnJvcihgUHJvZmlsZSAke3Byb2ZpbGVOYW1lfSBjb3VsZCBub3QgYmUgZm91bmQgaW4gc2hhcmVkIGNyZWRlbnRpYWxzIGZpbGUuYCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXhlY1Byb21pc2UoY29tbWFuZDogc3RyaW5nKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZXhlYyhjb21tYW5kLCAoZXJyb3IsIHN0ZG91dCkgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShzdGRvdXQudHJpbSgpKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iXX0=