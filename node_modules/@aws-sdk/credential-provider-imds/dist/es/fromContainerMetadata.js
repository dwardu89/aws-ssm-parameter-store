import { __assign, __awaiter, __generator } from "tslib";
import { ProviderError } from "@aws-sdk/property-provider";
import { parse } from "url";
import { httpRequest } from "./remoteProvider/httpRequest";
import { fromImdsCredentials, isImdsCredentials } from "./remoteProvider/ImdsCredentials";
import { providerConfigFromInit } from "./remoteProvider/RemoteProviderInit";
import { retry } from "./remoteProvider/retry";
export var ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
export var ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
export var ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
/**
 * Creates a credential provider that will source credentials from the ECS
 * Container Metadata Service
 */
export function fromContainerMetadata(init) {
    var _this = this;
    if (init === void 0) { init = {}; }
    var _a = providerConfigFromInit(init), timeout = _a.timeout, maxRetries = _a.maxRetries;
    return function () {
        return getCmdsUri().then(function (url) {
            return retry(function () { return __awaiter(_this, void 0, void 0, function () {
                var credsResponse, _a, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _b = (_a = JSON).parse;
                            return [4 /*yield*/, requestFromEcsImds(timeout, url)];
                        case 1:
                            credsResponse = _b.apply(_a, [_c.sent()]);
                            if (!isImdsCredentials(credsResponse)) {
                                throw new ProviderError("Invalid response received from instance metadata service.");
                            }
                            return [2 /*return*/, fromImdsCredentials(credsResponse)];
                    }
                });
            }); }, maxRetries);
        });
    };
}
function requestFromEcsImds(timeout, options) {
    if (process.env[ENV_CMDS_AUTH_TOKEN]) {
        var _a = options.headers, headers = _a === void 0 ? {} : _a;
        headers.Authorization = process.env[ENV_CMDS_AUTH_TOKEN];
        options.headers = headers;
    }
    return httpRequest(__assign(__assign({}, options), { timeout: timeout })).then(function (buffer) { return buffer.toString(); });
}
var CMDS_IP = "169.254.170.2";
var GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true,
};
var GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true,
};
function getCmdsUri() {
    if (process.env[ENV_CMDS_RELATIVE_URI]) {
        return Promise.resolve({
            hostname: CMDS_IP,
            path: process.env[ENV_CMDS_RELATIVE_URI],
        });
    }
    if (process.env[ENV_CMDS_FULL_URI]) {
        var parsed = parse(process.env[ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
            return Promise.reject(new ProviderError(parsed.hostname + " is not a valid container metadata service hostname", false));
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
            return Promise.reject(new ProviderError(parsed.protocol + " is not a valid container metadata service protocol", false));
        }
        return Promise.resolve(__assign(__assign({}, parsed), { port: parsed.port ? parseInt(parsed.port, 10) : undefined }));
    }
    return Promise.reject(new ProviderError("The container metadata credential provider cannot be used unless" +
        (" the " + ENV_CMDS_RELATIVE_URI + " or " + ENV_CMDS_FULL_URI + " environment") +
        " variable is set", false));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJvbUNvbnRhaW5lck1ldGFkYXRhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Zyb21Db250YWluZXJNZXRhZGF0YS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBRzNELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxLQUFLLENBQUM7QUFFNUIsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQzNELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQzFGLE9BQU8sRUFBRSxzQkFBc0IsRUFBc0IsTUFBTSxxQ0FBcUMsQ0FBQztBQUNqRyxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFL0MsTUFBTSxDQUFDLElBQU0saUJBQWlCLEdBQUcsb0NBQW9DLENBQUM7QUFDdEUsTUFBTSxDQUFDLElBQU0scUJBQXFCLEdBQUcsd0NBQXdDLENBQUM7QUFDOUUsTUFBTSxDQUFDLElBQU0sbUJBQW1CLEdBQUcsbUNBQW1DLENBQUM7QUFFdkU7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLHFCQUFxQixDQUFDLElBQTZCO0lBQW5FLGlCQWNDO0lBZHFDLHFCQUFBLEVBQUEsU0FBNkI7SUFDM0QsSUFBQSxLQUEwQixzQkFBc0IsQ0FBQyxJQUFJLENBQUMsRUFBcEQsT0FBTyxhQUFBLEVBQUUsVUFBVSxnQkFBaUMsQ0FBQztJQUM3RCxPQUFPO1FBQ0wsT0FBTyxVQUFVLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBQyxHQUFHO1lBQzNCLE9BQUEsS0FBSyxDQUFDOzs7Ozs0QkFDa0IsS0FBQSxDQUFBLEtBQUEsSUFBSSxDQUFBLENBQUMsS0FBSyxDQUFBOzRCQUFDLHFCQUFNLGtCQUFrQixDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFBQTs7NEJBQWpFLGFBQWEsR0FBRyxjQUFX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d3Mtc2RrL3Byb3BlcnR5LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBDcmVkZW50aWFsUHJvdmlkZXIgfSBmcm9tIFwiQGF3cy1zZGsvdHlwZXNcIjtcbmltcG9ydCB7IFJlcXVlc3RPcHRpb25zIH0gZnJvbSBcImh0dHBcIjtcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcInVybFwiO1xuXG5pbXBvcnQgeyBodHRwUmVxdWVzdCB9IGZyb20gXCIuL3JlbW90ZVByb3ZpZGVyL2h0dHBSZXF1ZXN0XCI7XG5pbXBvcnQgeyBmcm9tSW1kc0NyZWRlbnRpYWxzLCBpc0ltZHNDcmVkZW50aWFscyB9IGZyb20gXCIuL3JlbW90ZVByb3ZpZGVyL0ltZHNDcmVkZW50aWFsc1wiO1xuaW1wb3J0IHsgcHJvdmlkZXJDb25maWdGcm9tSW5pdCwgUmVtb3RlUHJvdmlkZXJJbml0IH0gZnJvbSBcIi4vcmVtb3RlUHJvdmlkZXIvUmVtb3RlUHJvdmlkZXJJbml0XCI7XG5pbXBvcnQgeyByZXRyeSB9IGZyb20gXCIuL3JlbW90ZVByb3ZpZGVyL3JldHJ5XCI7XG5cbmV4cG9ydCBjb25zdCBFTlZfQ01EU19GVUxMX1VSSSA9IFwiQVdTX0NPTlRBSU5FUl9DUkVERU5USUFMU19GVUxMX1VSSVwiO1xuZXhwb3J0IGNvbnN0IEVOVl9DTURTX1JFTEFUSVZFX1VSSSA9IFwiQVdTX0NPTlRBSU5FUl9DUkVERU5USUFMU19SRUxBVElWRV9VUklcIjtcbmV4cG9ydCBjb25zdCBFTlZfQ01EU19BVVRIX1RPS0VOID0gXCJBV1NfQ09OVEFJTkVSX0FVVEhPUklaQVRJT05fVE9LRU5cIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3JlZGVudGlhbCBwcm92aWRlciB0aGF0IHdpbGwgc291cmNlIGNyZWRlbnRpYWxzIGZyb20gdGhlIEVDU1xuICogQ29udGFpbmVyIE1ldGFkYXRhIFNlcnZpY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Db250YWluZXJNZXRhZGF0YShpbml0OiBSZW1vdGVQcm92aWRlckluaXQgPSB7fSk6IENyZWRlbnRpYWxQcm92aWRlciB7XG4gIGNvbnN0IHsgdGltZW91dCwgbWF4UmV0cmllcyB9ID0gcHJvdmlkZXJDb25maWdGcm9tSW5pdChpbml0KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZXR1cm4gZ2V0Q21kc1VyaSgpLnRoZW4oKHVybCkgPT5cbiAgICAgIHJldHJ5KGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgY3JlZHNSZXNwb25zZSA9IEpTT04ucGFyc2UoYXdhaXQgcmVxdWVzdEZyb21FY3NJbWRzKHRpbWVvdXQsIHVybCkpO1xuICAgICAgICBpZiAoIWlzSW1kc0NyZWRlbnRpYWxzKGNyZWRzUmVzcG9uc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFByb3ZpZGVyRXJyb3IoXCJJbnZhbGlkIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gaW5zdGFuY2UgbWV0YWRhdGEgc2VydmljZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbUltZHNDcmVkZW50aWFscyhjcmVkc1Jlc3BvbnNlKTtcbiAgICAgIH0sIG1heFJldHJpZXMpXG4gICAgKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEZyb21FY3NJbWRzKHRpbWVvdXQ6IG51bWJlciwgb3B0aW9uczogUmVxdWVzdE9wdGlvbnMpOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAocHJvY2Vzcy5lbnZbRU5WX0NNRFNfQVVUSF9UT0tFTl0pIHtcbiAgICBjb25zdCB7IGhlYWRlcnMgPSB7fSB9ID0gb3B0aW9ucztcbiAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBwcm9jZXNzLmVudltFTlZfQ01EU19BVVRIX1RPS0VOXTtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSBoZWFkZXJzO1xuICB9XG5cbiAgcmV0dXJuIGh0dHBSZXF1ZXN0KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHRpbWVvdXQsXG4gIH0pLnRoZW4oKGJ1ZmZlcikgPT4gYnVmZmVyLnRvU3RyaW5nKCkpO1xufVxuXG5jb25zdCBDTURTX0lQID0gXCIxNjkuMjU0LjE3MC4yXCI7XG5jb25zdCBHUkVFTkdSQVNTX0hPU1RTID0ge1xuICBsb2NhbGhvc3Q6IHRydWUsXG4gIFwiMTI3LjAuMC4xXCI6IHRydWUsXG59O1xuY29uc3QgR1JFRU5HUkFTU19QUk9UT0NPTFMgPSB7XG4gIFwiaHR0cDpcIjogdHJ1ZSxcbiAgXCJodHRwczpcIjogdHJ1ZSxcbn07XG5cbmZ1bmN0aW9uIGdldENtZHNVcmkoKTogUHJvbWlzZTxSZXF1ZXN0T3B0aW9ucz4ge1xuICBpZiAocHJvY2Vzcy5lbnZbRU5WX0NNRFNfUkVMQVRJVkVfVVJJXSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgaG9zdG5hbWU6IENNRFNfSVAsXG4gICAgICBwYXRoOiBwcm9jZXNzLmVudltFTlZfQ01EU19SRUxBVElWRV9VUkldLFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52W0VOVl9DTURTX0ZVTExfVVJJXSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHByb2Nlc3MuZW52W0VOVl9DTURTX0ZVTExfVVJJXSEpO1xuICAgIGlmICghcGFyc2VkLmhvc3RuYW1lIHx8ICEocGFyc2VkLmhvc3RuYW1lIGluIEdSRUVOR1JBU1NfSE9TVFMpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBQcm92aWRlckVycm9yKGAke3BhcnNlZC5ob3N0bmFtZX0gaXMgbm90IGEgdmFsaWQgY29udGFpbmVyIG1ldGFkYXRhIHNlcnZpY2UgaG9zdG5hbWVgLCBmYWxzZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgIShwYXJzZWQucHJvdG9jb2wgaW4gR1JFRU5HUkFTU19QUk9UT0NPTFMpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBQcm92aWRlckVycm9yKGAke3BhcnNlZC5wcm90b2NvbH0gaXMgbm90IGEgdmFsaWQgY29udGFpbmVyIG1ldGFkYXRhIHNlcnZpY2UgcHJvdG9jb2xgLCBmYWxzZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAuLi5wYXJzZWQsXG4gICAgICBwb3J0OiBwYXJzZWQucG9ydCA/IHBhcnNlSW50KHBhcnNlZC5wb3J0LCAxMCkgOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgbmV3IFByb3ZpZGVyRXJyb3IoXG4gICAgICBcIlRoZSBjb250YWluZXIgbWV0YWRhdGEgY3JlZGVudGlhbCBwcm92aWRlciBjYW5ub3QgYmUgdXNlZCB1bmxlc3NcIiArXG4gICAgICAgIGAgdGhlICR7RU5WX0NNRFNfUkVMQVRJVkVfVVJJfSBvciAke0VOVl9DTURTX0ZVTExfVVJJfSBlbnZpcm9ubWVudGAgK1xuICAgICAgICBcIiB2YXJpYWJsZSBpcyBzZXRcIixcbiAgICAgIGZhbHNlXG4gICAgKVxuICApO1xufVxuIl19